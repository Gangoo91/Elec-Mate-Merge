import jsPDF from 'jspdf';
import 'jspdf-autotable';
import { format as formatDate } from "date-fns";
import { safeText } from './rams-pdf-helpers';

// Extend jsPDF with autoTable
declare module 'jspdf' {
  interface jsPDF {
    autoTable: (options: any) => jsPDF;
  }
}

interface LaTeXStylePDFOptions {
  title?: string;
  author?: string;
  subject?: string;
  keywords?: string;
  includeTableOfContents?: boolean;
  fontFamily?: 'serif' | 'sans-serif' | 'monospace';
  fontSize?: number;
  margins?: { top: number; right: number; bottom: number; left: number; };
  companyName?: string;
  logoUrl?: string;
  includeSignatures?: boolean;
  watermark?: string;
  certificateType?: string;
  documentId?: string;
}

interface DocumentSection {
  level: number;
  title: string;
  content: string;
  pageNumber?: number;
}

/**
 * Professional LaTeX-style PDF generator for Markdown content
 * Creates publication-quality documents with sophisticated typography
 */
export const generateLaTeXStylePDF = async (
  markdownContent: string,
  filename?: string,
  options: LaTeXStylePDFOptions = {}
): Promise<void> => {
  try {
    console.log('Starting LaTeX-style PDF generation...');
    
    const {
      title = 'Professional Document',
      author = 'Generated by Lovable',
      subject = 'Electrical Installation Certificate',
      keywords = 'electrical, certificate, BS7671, compliance',
      includeTableOfContents = false,
      fontFamily = 'sans-serif',
      fontSize = 10,
      margins = { top: 25, right: 20, bottom: 25, left: 20 },
      companyName,
      logoUrl,
      includeSignatures = true,
      watermark,
      certificateType = 'Minor Electrical Installation Works Certificate',
      documentId
    } = options;
    
    // Clean and preprocess content
    const cleanContent = safeText(markdownContent);
    
    const pdf = new jsPDF('p', 'mm', 'a4');
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    
    // Set document metadata
    pdf.setProperties({
      title: safeText(title),
      author: safeText(author),
      subject: safeText(subject),
      keywords: safeText(keywords),
      creator: 'Lovable Professional PDF Generator'
    });
    
    let yPosition = margins.top;
    let currentPage = 1;
    const sectionsForTOC: DocumentSection[] = [];
    
    // Professional font configuration for electrical certificates
    const getFontConfig = (weight: 'normal' | 'bold' = 'normal', style: 'normal' | 'italic' = 'normal') => {
      const baseFont = 'helvetica'; // Always use Arial/Helvetica for professional look
      let fontName = baseFont;
      
      if (weight === 'bold' && style === 'italic') {
        fontName = baseFont + '-bolditalic';
      } else if (weight === 'bold') {
        fontName = baseFont + '-bold';
      } else if (style === 'italic') {
        fontName = baseFont + '-oblique';
      }
      
      return fontName;
    };
    
    // Optimized line height calculations (1.3x font size for better readability)
    const getLineHeight = (fontSizeValue: number) => Math.round(fontSizeValue * 1.3);
    
    // Smart text measurement using canvas for accurate wrapping
    const measureText = (text: string, fontSizeValue: number, fontName: string): number => {
      // Create temporary canvas context for accurate measurement
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      if (context) {
        context.font = `${fontSizeValue}px ${fontName}`;
        return context.measureText(text).width * 0.352778; // Convert px to mm
      }
      return pdf.getTextWidth(text); // Fallback to jsPDF measurement
    };
    
    // Intelligent word wrapping with hyphenation support
    const wrapText = (text: string, maxWidth: number, fontSizeValue: number, fontName: string): string[] => {
      const words = text.split(' ');
      const lines: string[] = [];
      let currentLine = '';
      
      for (const word of words) {
        const testLine = currentLine ? `${currentLine} ${word}` : word;
        const testWidth = measureText(testLine, fontSizeValue, fontName);
        
        if (testWidth <= maxWidth) {
          currentLine = testLine;
        } else {
          if (currentLine) {
            lines.push(currentLine);
            currentLine = word;
          } else {
            // Word is too long, try to hyphenate
            if (word.length > 10) {
              const hyphenPoint = Math.floor(word.length * 0.7);
              lines.push(word.substring(0, hyphenPoint) + '-');
              currentLine = word.substring(hyphenPoint);
            } else {
              lines.push(word);
            }
          }
        }
      }
      
      if (currentLine) {
        lines.push(currentLine);
      }
      
      return lines.length > 0 ? lines : [''];
    };
    
    // Professional page setup
    const addPageNumbers = () => {
      const totalPages = pdf.getNumberOfPages();
      
      for (let i = 1; i <= totalPages; i++) {
        pdf.setPage(i);
        
        // Footer with page numbers
        pdf.setFont(getFontConfig(), 'normal');
        pdf.setFontSize(9);
        pdf.setTextColor(100, 100, 100);
        
        if (i > 1) { // Skip page number on title page
          pdf.text(`${i - 1}`, pageWidth / 2, pageHeight - 15, { align: 'center' });
        }
        
        // Header with document title (except title page)
        if (i > 1) {
          pdf.setDrawColor(200, 200, 200);
          pdf.setLineWidth(0.3);
          pdf.line(margins.left, margins.top - 5, pageWidth - margins.right, margins.top - 5);
          
          pdf.setFontSize(8);
          pdf.setTextColor(120, 120, 120);
          pdf.text(safeText(title), margins.left, margins.top - 8);
          pdf.text(formatDate(new Date(), 'MMMM yyyy'), pageWidth - margins.right, margins.top - 8, { align: 'right' });
        }
      }
    };
    
    // Create professional electrical certificate header
    const createCertificateHeader = () => {
      let yPos = margins.top;
      
      // Company header section
      pdf.setDrawColor(0, 0, 0);
      pdf.setLineWidth(1);
      pdf.rect(margins.left, yPos, pageWidth - margins.left - margins.right, 35);
      
      // Company name and logo area
      if (companyName) {
        pdf.setFont(getFontConfig('bold'), 'bold');
        pdf.setFontSize(14);
        pdf.setTextColor(0, 0, 0);
        pdf.text(safeText(companyName), margins.left + 5, yPos + 8);
      }
      
      // Certificate title
      pdf.setFont(getFontConfig('bold'), 'bold');
      pdf.setFontSize(16);
      pdf.setTextColor(0, 0, 0);
      pdf.text(certificateType, pageWidth / 2, yPos + 20, { align: 'center' });
      
      // BS 7671 compliance text
      pdf.setFont(getFontConfig(), 'normal');
      pdf.setFontSize(9);
      pdf.setTextColor(0, 0, 0);
      pdf.text('(Requirements for Electrical Installations - BS 7671:2018+A2:2022)', pageWidth / 2, yPos + 28, { align: 'center' });
      
      yPos += 45;
      
      // Document ID and date section
      pdf.setDrawColor(0, 0, 0);
      pdf.setLineWidth(0.5);
      pdf.rect(margins.left, yPos, pageWidth - margins.left - margins.right, 20);
      
      // Document details
      pdf.setFont(getFontConfig(), 'normal');
      pdf.setFontSize(10);
      pdf.setTextColor(0, 0, 0);
      
      if (documentId) {
        pdf.text(`Certificate No: ${documentId}`, margins.left + 5, yPos + 8);
      }
      
      const dateStr = formatDate(new Date(), 'dd/MM/yyyy');
      pdf.text(`Date: ${dateStr}`, pageWidth - margins.right - 40, yPos + 8);
      
      if (watermark) {
        pdf.setFont(getFontConfig('bold'), 'bold');
        pdf.setFontSize(10);
        pdf.setTextColor(200, 0, 0);
        pdf.text(watermark, pageWidth / 2, yPos + 15, { align: 'center' });
      }
      
      return yPos + 30; // Return new Y position
    };
    
    // Parse markdown and extract sections
    const parseMarkdownSections = (content: string): DocumentSection[] => {
      const lines = content.split('\n');
      const parsedSections: DocumentSection[] = [];
      let currentSection: DocumentSection | null = null;
      
      for (const line of lines) {
        const trimmed = line.trim();
        
        // Check for headers
        const headerMatch = trimmed.match(/^(#{1,6})\s+(.+)/);
        if (headerMatch) {
          // Save previous section
          if (currentSection) {
            parsedSections.push(currentSection);
          }
          
          // Start new section
          currentSection = {
            level: headerMatch[1].length,
            title: safeText(headerMatch[2]),
            content: ''
          };
        } else if (currentSection) {
          currentSection.content += line + '\n';
        } else if (trimmed) {
          // Content before first header
          if (!currentSection) {
            currentSection = {
              level: 0,
              title: '',
              content: line + '\n'
            };
          }
        }
      }
      
      if (currentSection) {
        parsedSections.push(currentSection);
      }
      
      return parsedSections;
    };
    
    // Table of Contents generation
    const createTableOfContents = (sections: DocumentSection[]) => {
      pdf.addPage();
      yPosition = margins.top + 20;
      
      // TOC Title
      pdf.setFont(getFontConfig('bold'), 'bold');
      pdf.setFontSize(20);
      pdf.setTextColor(30, 30, 30);
      pdf.text('Table of Contents', margins.left, yPosition);
      yPosition += 20;
      
      // TOC Line
      pdf.setDrawColor(70, 130, 180);
      pdf.setLineWidth(1);
      pdf.line(margins.left, yPosition, pageWidth - margins.right, yPosition);
      yPosition += 15;
      
      // TOC Entries
      pdf.setFont(getFontConfig(), 'normal');
      
      sections.forEach((section) => {
        if (section.level > 0 && section.level <= 3) {
          const indent = (section.level - 1) * 8;
          const dotSize = section.level === 1 ? 12 : section.level === 2 ? 11 : 10;
          
          pdf.setFontSize(dotSize);
          pdf.setTextColor(section.level === 1 ? 40 : section.level === 2 ? 60 : 80, 40, 40);
          
          const entryText = section.title;
          const pageNum = section.pageNumber || 1;
          
          // Entry title
          pdf.text(entryText, margins.left + indent, yPosition);
          
          // Dotted line
          const textWidth = pdf.getTextWidth(entryText);
          const pageNumWidth = pdf.getTextWidth(pageNum.toString());
          const dotsSpace = pageWidth - margins.right - margins.left - indent - textWidth - pageNumWidth - 5;
          const dotCount = Math.floor(dotsSpace / 3);
          
          if (dotCount > 0) {
            pdf.setTextColor(150, 150, 150);
            pdf.setFontSize(8);
            const dots = '.'.repeat(dotCount);
            pdf.text(dots, margins.left + indent + textWidth + 2, yPosition);
          }
          
          // Page number
          pdf.setTextColor(40, 40, 40);
          pdf.setFontSize(dotSize);
          pdf.text(pageNum.toString(), pageWidth - margins.right, yPosition, { align: 'right' });
          
          yPosition += section.level === 1 ? 8 : 6;
          
          if (yPosition > pageHeight - margins.bottom - 20) {
            pdf.addPage();
            yPosition = margins.top + 20;
          }
        }
      });
      
      currentPage = pdf.getNumberOfPages() + 1;
    };
    
    // Intelligent page break with content awareness
    const checkPageBreak = (requiredSpace: number, preventOrphans: boolean = true) => {
      const spaceRemaining = pageHeight - margins.bottom - yPosition;
      
      if (spaceRemaining < requiredSpace) {
        // Prevent orphan lines (less than 2 lines remaining)
        if (preventOrphans && spaceRemaining < getLineHeight(fontSize) * 2) {
          pdf.addPage();
          yPosition = margins.top;
          return true;
        } else if (spaceRemaining < requiredSpace) {
          pdf.addPage();
          yPosition = margins.top;
          return true;
        }
      }
      return false;
    };
    
    // Render content with professional formatting
    const renderContent = (sections: DocumentSection[]) => {
      sections.forEach((section, index) => {
        section.pageNumber = pdf.getNumberOfPages();
        
        if (section.level > 0) {
          // Section headers
          checkPageBreak(20);
          
          const headerSizes = { 1: 18, 2: 16, 3: 14, 4: 12, 5: 11, 6: 10 };
          const headerSize = headerSizes[section.level as keyof typeof headerSizes] || 10;
          
          pdf.setFont(getFontConfig('bold'), 'bold');
          pdf.setFontSize(headerSize);
          pdf.setTextColor(30, 30, 30);
          
          // Optimized spacing before headers
          if (index > 0) {
            yPosition += section.level === 1 ? 12 : section.level === 2 ? 8 : 6;
          }
          
          pdf.text(section.title, margins.left, yPosition);
          yPosition += getLineHeight(headerSize) * 0.4;
          
          // Underline for main headers
          if (section.level <= 2) {
            pdf.setDrawColor(section.level === 1 ? 70 : 150, section.level === 1 ? 130 : 150, section.level === 1 ? 180 : 150);
            pdf.setLineWidth(section.level === 1 ? 1.5 : 0.8);
            pdf.line(margins.left, yPosition + 2, margins.left + pdf.getTextWidth(section.title), yPosition + 2);
          }
          
          yPosition += 6;
        }
        
        // Section content
        if (section.content.trim()) {
          renderMarkdownContent(section.content);
        }
      });
    };
    
    // Render markdown content with enhanced formatting
    const renderMarkdownContent = (content: string) => {
      const lines = content.split('\n');
      let inCodeBlock = false;
      let inList = false;
      
      for (const line of lines) {
        const trimmed = line.trim();
        
        if (!trimmed) {
          yPosition += getLineHeight(fontSize) * 0.3; // Reduced empty line spacing
          continue;
        }
        
        checkPageBreak(20);
        
        // Code blocks
        if (trimmed.startsWith('```')) {
          inCodeBlock = !inCodeBlock;
          if (inCodeBlock) {
            yPosition += 5;
            // Code block background
            const codeBlockHeight = 8;
            pdf.setFillColor(248, 248, 248);
            pdf.rect(margins.left - 2, yPosition - 2, pageWidth - margins.left - margins.right + 4, codeBlockHeight, 'F');
          } else {
            yPosition += 5;
          }
          continue;
        }
        
        if (inCodeBlock) {
          pdf.setFont('courier', 'normal');
          pdf.setFontSize(9);
          pdf.setTextColor(60, 60, 60);
          pdf.text(line, margins.left + 5, yPosition);
          yPosition += 5;
          continue;
        }
        
        // Enhanced list formatting with proper spacing
        if (trimmed.match(/^[-\*\+]\s/)) {
          if (!inList) {
            yPosition += 2;
            inList = true;
          }
          
          pdf.setFont(getFontConfig(), 'normal');
          pdf.setFontSize(fontSize);
          pdf.setTextColor(50, 50, 50);
          
          const listText = trimmed.replace(/^[-\*\+]\s/, 'â€¢ ');
          const processedText = processInlineFormatting(listText);
          
          // Use enhanced text wrapping
          const availableWidth = pageWidth - margins.left - margins.right - 10;
          const wrappedLines = wrapText(processedText, availableWidth, fontSize, getFontConfig());
          
          wrappedLines.forEach((textLine: string, index: number) => {
            checkPageBreak(getLineHeight(fontSize));
            pdf.text(textLine, margins.left + (index === 0 ? 8 : 18), yPosition);
            yPosition += getLineHeight(fontSize) * 0.85; // Tighter line spacing for lists
          });
          
          continue;
        } else {
          inList = false;
        }
        
        // Enhanced table support
        if (trimmed.startsWith('|')) {
          // Collect all table rows
          const tableRows = [line];
          let nextLineIndex = lines.indexOf(line) + 1;
          
          while (nextLineIndex < lines.length) {
            const nextLine = lines[nextLineIndex];
            if (nextLine.trim().startsWith('|')) {
              tableRows.push(nextLine);
              nextLineIndex++;
            } else {
              break;
            }
          }
          
          renderTable(tableRows);
          
          // Skip the processed table lines
          for (let i = 0; i < tableRows.length - 1; i++) {
            lines.splice(lines.indexOf(line) + 1, 1);
          }
          continue;
        }
        
        // Blockquotes
        if (trimmed.startsWith('>')) {
          pdf.setFillColor(245, 245, 245);
          const quoteHeight = 12;
          pdf.rect(margins.left - 2, yPosition - 2, pageWidth - margins.left - margins.right + 4, quoteHeight, 'F');
          
          pdf.setFont(getFontConfig('normal', 'italic'), 'italic');
          pdf.setFontSize(fontSize - 1);
          pdf.setTextColor(80, 80, 80);
          
          const quoteText = trimmed.replace(/^>\s*/, '');
          pdf.text(quoteText, margins.left + 5, yPosition + 2);
          yPosition += 15;
          continue;
        }
        
        // Enhanced paragraph rendering with smart text wrapping
        pdf.setFont(getFontConfig(), 'normal');
        pdf.setFontSize(fontSize);
        pdf.setTextColor(40, 40, 40);
        
        const processedText = processInlineFormatting(trimmed);
        const availableWidth = pageWidth - margins.left - margins.right;
        const wrappedLines = wrapText(processedText, availableWidth, fontSize, getFontConfig());
        
        wrappedLines.forEach((textLine: string, lineIndex: number) => {
          checkPageBreak(getLineHeight(fontSize), true);
          pdf.text(textLine, margins.left, yPosition);
          yPosition += getLineHeight(fontSize) * 0.95; // Optimized line spacing
        });
        
        yPosition += getLineHeight(fontSize) * 0.4; // Reduced paragraph spacing
      }
    };
    
    // Enhanced inline formatting processor with better markdown support
    const processInlineFormatting = (text: string): string => {
      // Clean up excessive whitespace and HTML entities
      text = text.replace(/\s+/g, ' ').trim();
      text = text.replace(/&#x26;/g, '&');
      text = text.replace(/&#39;/g, "'");
      text = text.replace(/&quot;/g, '"');
      text = text.replace(/&lt;/g, '<');
      text = text.replace(/&gt;/g, '>');
      text = text.replace(/&amp;/g, '&');
      
      // Handle code spans by replacing with monospace indicators
      text = text.replace(/`([^`]+)`/g, '[CODE]$1[/CODE]');
      
      // Remove markdown formatting but preserve structure for electrical content
      text = text
        .replace(/\*\*(.*?)\*\*/g, '$1')  // Bold
        .replace(/\*(.*?)\*/g, '$1')      // Italic
        .replace(/\[CODE\](.*?)\[\/CODE\]/g, '$1'); // Restore code content
      
      return text;
    };
    
    // Add professional signature section for electrical certificates
    const addSignatureSection = () => {
      // Ensure adequate space for signatures
      if (yPosition > pageHeight - 100) {
        pdf.addPage();
        yPosition = margins.top;
      }
      
      yPosition += 20;
      
      // Signatures title
      pdf.setFont(getFontConfig('bold'), 'bold');
      pdf.setFontSize(12);
      pdf.setTextColor(0, 0, 0);
      pdf.text('Signatures', margins.left, yPosition);
      yPosition += 15;
      
      // Signature boxes
      const signatureBoxHeight = 25;
      const signatureBoxWidth = (pageWidth - margins.left - margins.right - 10) / 2;
      
      // Inspector signature
      pdf.setDrawColor(0, 0, 0);
      pdf.setLineWidth(0.5);
      pdf.rect(margins.left, yPosition, signatureBoxWidth, signatureBoxHeight);
      
      pdf.setFont(getFontConfig(), 'normal');
      pdf.setFontSize(10);
      pdf.setTextColor(0, 0, 0);
      pdf.text('For construction work carried out by:', margins.left + 2, yPosition + 8);
      pdf.text('Signature:', margins.left + 2, yPosition + 15);
      pdf.text('Date:', margins.left + 2, yPosition + 22);
      
      // Client signature
      pdf.rect(margins.left + signatureBoxWidth + 10, yPosition, signatureBoxWidth, signatureBoxHeight);
      pdf.text('For the person ordering the work:', margins.left + signatureBoxWidth + 12, yPosition + 8);
      pdf.text('Signature:', margins.left + signatureBoxWidth + 12, yPosition + 15);
      pdf.text('Date:', margins.left + signatureBoxWidth + 12, yPosition + 22);
      
      yPosition += signatureBoxHeight + 10;
      
      // Compliance statement
      pdf.setFont(getFontConfig(), 'normal');
      pdf.setFontSize(9);
      pdf.setTextColor(0, 0, 0);
      const complianceText = 'I/We being the person(s) responsible for the work detailed in this certificate, particulars of which are described above, having exercised reasonable skill and care when carrying out the work, hereby CERTIFY that the work for which I/we have been responsible is to the best of my/our knowledge and belief in accordance with BS 7671:2018+A2:2022, amended to ' + formatDate(new Date(), 'MMMM yyyy') + '. The work has been designed, constructed, inspected and tested in accordance with BS 7671:2018+A2:2022 (Requirements for Electrical Installations).';
      
      const wrappedComplianceText = pdf.splitTextToSize(complianceText, pageWidth - margins.left - margins.right);
      wrappedComplianceText.forEach((line: string) => {
        if (yPosition > pageHeight - margins.bottom - 10) {
          pdf.addPage();
          yPosition = margins.top;
        }
        pdf.text(line, margins.left, yPosition);
        yPosition += 5;
      });
    };
    
    // Professional table rendering with autoTable
    const renderTable = (tableData: string[]) => {
      if (tableData.length === 0) return;
      
      // Parse table data
      const rows = tableData.map(row => 
        row.split('|').map(cell => safeText(cell.trim())).filter(cell => cell)
      );
      
      if (rows.length === 0) return;
      
      const headers = rows[0];
      const dataRows = rows.slice(1).filter(row => !row.every(cell => cell.match(/^-+$/)));
      
      if (dataRows.length === 0) return;
      
      checkPageBreak(30);
      
      // Use autoTable for professional table formatting
      pdf.autoTable({
        head: [headers],
        body: dataRows,
        startY: yPosition,
        margin: { left: margins.left, right: margins.right },
        styles: {
          fontSize: 9,
          cellPadding: 3,
          lineColor: [0, 0, 0],
          lineWidth: 0.5,
          textColor: [0, 0, 0],
          font: 'helvetica'
        },
        headStyles: {
          fillColor: [240, 240, 240],
          fontStyle: 'bold',
          halign: 'left'
        },
        bodyStyles: {
          fillColor: [255, 255, 255],
          halign: 'left'
        },
        alternateRowStyles: {
          fillColor: [248, 248, 248]
        },
        columnStyles: {
          0: { cellWidth: 'auto' },
          1: { cellWidth: 'auto' }
        }
      });
      
      yPosition = (pdf as any).lastAutoTable.finalY + 10;
    };
    
    // Generate the professional electrical certificate
    yPosition = createCertificateHeader();
    
    const documentSections = parseMarkdownSections(cleanContent);
    
    // Render content without title page or TOC for certificates
    renderContent(documentSections);
    
    // Add signature section if requested
    if (includeSignatures) {
      addSignatureSection();
    }
    
    // Add page numbers and headers
    addPageNumbers();
    
    // Generate filename
    const safeTitle = safeText(title).toLowerCase().replace(/[^a-z0-9]+/g, '-');
    const finalFilename = filename || `${safeTitle}-${formatDate(new Date(), 'yyyy-MM-dd')}.pdf`;
    
    // Save the PDF
    pdf.save(finalFilename);
    console.log('LaTeX-style PDF generated successfully');
    
  } catch (error) {
    console.error('LaTeX-style PDF generation failed:', error);
    throw new Error(`LaTeX-style PDF generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
};

// Sample markdown content for demonstration
export const sampleMarkdown = `# Professional Document Template

Welcome to this beautiful, professionally formatted document that demonstrates the power of our LaTeX-style PDF generation system.

## Introduction

This document showcases various formatting capabilities that make your content look polished and professional. The typography is carefully chosen to be easy on the eyes while maintaining a scholarly appearance.

### Key Features

Our PDF generation system includes:

- **Beautiful Typography**: Clean, readable fonts with proper spacing
- **Professional Layout**: Margins, headers, and page numbers positioned perfectly
- **Table of Contents**: Automatic generation for easy navigation
- **Multiple Formats**: Support for various markdown elements

### Advanced Formatting

You can include various types of content:

#### Code Examples

Here's a simple code block:

\`\`\`javascript
function generatePDF() {
  console.log("Creating beautiful documents!");
  return "Success";
}
\`\`\`

#### Lists and Structure

1. **Ordered Lists**: Perfect for step-by-step instructions
2. **Unordered Lists**: Great for feature highlights
3. **Nested Content**: Supports multiple levels of organization

Key benefits:
- Professional appearance
- Easy to read
- Consistent formatting
- Print-ready quality

#### Quotes and Emphasis

> "The best documents are those that communicate clearly and look professional while doing so."

This system ensures your content always looks its best, whether you're creating:

- Technical documentation
- Business reports  
- Academic papers
- Project proposals

## Technical Specifications

The PDF generation system uses advanced typography principles:

| Feature | Implementation | Quality |
|---------|---------------|---------|
| Font Selection | Professional typefaces | Excellent |
| Spacing | Optimal line height | Superior |
| Layout | LaTeX-inspired margins | Perfect |
| Navigation | TOC generation | Automatic |

## Conclusion

This professional PDF generation system transforms your markdown content into publication-quality documents that are perfect for business, academic, or personal use.

The combination of careful typography, proper spacing, and professional layout ensures your content always makes the best impression.

---

*Generated with care by the Lovable Professional PDF System*`;