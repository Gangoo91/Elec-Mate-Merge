import jsPDF from 'jspdf';
import 'jspdf-autotable';
import { format as formatDate } from "date-fns";
import { safeText } from './rams-pdf-helpers';

// Extend jsPDF with autoTable
declare module 'jspdf' {
  interface jsPDF {
    autoTable: (options: any) => jsPDF;
  }
}

interface LaTeXStylePDFOptions {
  title?: string;
  author?: string;
  subject?: string;
  keywords?: string;
  includeTableOfContents?: boolean;
  fontFamily?: 'serif' | 'sans-serif' | 'monospace';
  fontSize?: number;
  margins?: { top: number; right: number; bottom: number; left: number; };
}

interface DocumentSection {
  level: number;
  title: string;
  content: string;
  pageNumber?: number;
}

/**
 * Professional LaTeX-style PDF generator for Markdown content
 * Creates publication-quality documents with sophisticated typography
 */
export const generateLaTeXStylePDF = async (
  markdownContent: string,
  filename?: string,
  options: LaTeXStylePDFOptions = {}
): Promise<void> => {
  try {
    console.log('Starting LaTeX-style PDF generation...');
    
    const {
      title = 'Professional Document',
      author = 'Generated by Lovable',
      subject = 'Markdown to PDF Conversion',
      keywords = 'professional, document, pdf',
      includeTableOfContents = true,
      fontFamily = 'serif',
      fontSize = 11,
      margins = { top: 20, right: 15, bottom: 20, left: 15 }
    } = options;
    
    // Clean and preprocess content
    const cleanContent = safeText(markdownContent);
    
    const pdf = new jsPDF('p', 'mm', 'a4');
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    
    // Set document metadata
    pdf.setProperties({
      title: safeText(title),
      author: safeText(author),
      subject: safeText(subject),
      keywords: safeText(keywords),
      creator: 'Lovable Professional PDF Generator'
    });
    
    let yPosition = margins.top;
    let currentPage = 1;
    const sectionsForTOC: DocumentSection[] = [];
    
    // Enhanced font configuration with proper line height
    const getFontConfig = (weight: 'normal' | 'bold' = 'normal', style: 'normal' | 'italic' = 'normal') => {
      const baseFont = fontFamily === 'serif' ? 'times' : fontFamily === 'monospace' ? 'courier' : 'helvetica';
      let fontName = baseFont;
      
      if (weight === 'bold' && style === 'italic') {
        fontName = baseFont + '-bolditalic';
      } else if (weight === 'bold') {
        fontName = baseFont + '-bold';
      } else if (style === 'italic') {
        fontName = baseFont + '-oblique';
      }
      
      return fontName;
    };
    
    // Optimized line height calculations (1.3x font size for better readability)
    const getLineHeight = (fontSizeValue: number) => Math.round(fontSizeValue * 1.3);
    
    // Smart text measurement using canvas for accurate wrapping
    const measureText = (text: string, fontSizeValue: number, fontName: string): number => {
      // Create temporary canvas context for accurate measurement
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      if (context) {
        context.font = `${fontSizeValue}px ${fontName}`;
        return context.measureText(text).width * 0.352778; // Convert px to mm
      }
      return pdf.getTextWidth(text); // Fallback to jsPDF measurement
    };
    
    // Intelligent word wrapping with hyphenation support
    const wrapText = (text: string, maxWidth: number, fontSizeValue: number, fontName: string): string[] => {
      const words = text.split(' ');
      const lines: string[] = [];
      let currentLine = '';
      
      for (const word of words) {
        const testLine = currentLine ? `${currentLine} ${word}` : word;
        const testWidth = measureText(testLine, fontSizeValue, fontName);
        
        if (testWidth <= maxWidth) {
          currentLine = testLine;
        } else {
          if (currentLine) {
            lines.push(currentLine);
            currentLine = word;
          } else {
            // Word is too long, try to hyphenate
            if (word.length > 10) {
              const hyphenPoint = Math.floor(word.length * 0.7);
              lines.push(word.substring(0, hyphenPoint) + '-');
              currentLine = word.substring(hyphenPoint);
            } else {
              lines.push(word);
            }
          }
        }
      }
      
      if (currentLine) {
        lines.push(currentLine);
      }
      
      return lines.length > 0 ? lines : [''];
    };
    
    // Professional page setup
    const addPageNumbers = () => {
      const totalPages = pdf.getNumberOfPages();
      
      for (let i = 1; i <= totalPages; i++) {
        pdf.setPage(i);
        
        // Footer with page numbers
        pdf.setFont(getFontConfig(), 'normal');
        pdf.setFontSize(9);
        pdf.setTextColor(100, 100, 100);
        
        if (i > 1) { // Skip page number on title page
          pdf.text(`${i - 1}`, pageWidth / 2, pageHeight - 15, { align: 'center' });
        }
        
        // Header with document title (except title page)
        if (i > 1) {
          pdf.setDrawColor(200, 200, 200);
          pdf.setLineWidth(0.3);
          pdf.line(margins.left, margins.top - 5, pageWidth - margins.right, margins.top - 5);
          
          pdf.setFontSize(8);
          pdf.setTextColor(120, 120, 120);
          pdf.text(safeText(title), margins.left, margins.top - 8);
          pdf.text(formatDate(new Date(), 'MMMM yyyy'), pageWidth - margins.right, margins.top - 8, { align: 'right' });
        }
      }
    };
    
    // Create stunning title page
    const createTitlePage = () => {
      // Background subtle gradient effect using rectangles
      for (let i = 0; i < 20; i++) {
        const alpha = 1 - (i / 30);
        const grayValue = 250 - (i * 2);
        pdf.setFillColor(grayValue, grayValue, grayValue);
        pdf.rect(0, i * 10, pageWidth, 10, 'F');
      }
      
      // Main title
      pdf.setFont(getFontConfig('bold'), 'bold');
      pdf.setFontSize(28);
      pdf.setTextColor(30, 30, 30);
      
      const titleLines = pdf.splitTextToSize(safeText(title), pageWidth - 2 * margins.left);
      let titleY = pageHeight * 0.35;
      
      titleLines.forEach((line: string) => {
        pdf.text(line, pageWidth / 2, titleY, { align: 'center' });
        titleY += 12;
      });
      
      // Decorative line
      pdf.setDrawColor(70, 130, 180);
      pdf.setLineWidth(2);
      pdf.line(pageWidth * 0.25, titleY + 10, pageWidth * 0.75, titleY + 10);
      
      // Author
      if (author) {
        pdf.setFont(getFontConfig(), 'normal');
        pdf.setFontSize(16);
        pdf.setTextColor(60, 60, 60);
        pdf.text(safeText(author), pageWidth / 2, titleY + 30, { align: 'center' });
      }
      
      // Date with elegant formatting
      pdf.setFont(getFontConfig(), 'normal');
      pdf.setFontSize(12);
      pdf.setTextColor(100, 100, 100);
      const dateStr = formatDate(new Date(), 'EEEE, MMMM do, yyyy');
      pdf.text(dateStr, pageWidth / 2, pageHeight * 0.8, { align: 'center' });
      
      // Add subtle border
      pdf.setDrawColor(220, 220, 220);
      pdf.setLineWidth(1);
      pdf.rect(15, 15, pageWidth - 30, pageHeight - 30);
      
      currentPage++;
    };
    
    // Parse markdown and extract sections
    const parseMarkdownSections = (content: string): DocumentSection[] => {
      const lines = content.split('\n');
      const parsedSections: DocumentSection[] = [];
      let currentSection: DocumentSection | null = null;
      
      for (const line of lines) {
        const trimmed = line.trim();
        
        // Check for headers
        const headerMatch = trimmed.match(/^(#{1,6})\s+(.+)/);
        if (headerMatch) {
          // Save previous section
          if (currentSection) {
            parsedSections.push(currentSection);
          }
          
          // Start new section
          currentSection = {
            level: headerMatch[1].length,
            title: safeText(headerMatch[2]),
            content: ''
          };
        } else if (currentSection) {
          currentSection.content += line + '\n';
        } else if (trimmed) {
          // Content before first header
          if (!currentSection) {
            currentSection = {
              level: 0,
              title: '',
              content: line + '\n'
            };
          }
        }
      }
      
      if (currentSection) {
        parsedSections.push(currentSection);
      }
      
      return parsedSections;
    };
    
    // Table of Contents generation
    const createTableOfContents = (sections: DocumentSection[]) => {
      pdf.addPage();
      yPosition = margins.top + 20;
      
      // TOC Title
      pdf.setFont(getFontConfig('bold'), 'bold');
      pdf.setFontSize(20);
      pdf.setTextColor(30, 30, 30);
      pdf.text('Table of Contents', margins.left, yPosition);
      yPosition += 20;
      
      // TOC Line
      pdf.setDrawColor(70, 130, 180);
      pdf.setLineWidth(1);
      pdf.line(margins.left, yPosition, pageWidth - margins.right, yPosition);
      yPosition += 15;
      
      // TOC Entries
      pdf.setFont(getFontConfig(), 'normal');
      
      sections.forEach((section) => {
        if (section.level > 0 && section.level <= 3) {
          const indent = (section.level - 1) * 8;
          const dotSize = section.level === 1 ? 12 : section.level === 2 ? 11 : 10;
          
          pdf.setFontSize(dotSize);
          pdf.setTextColor(section.level === 1 ? 40 : section.level === 2 ? 60 : 80, 40, 40);
          
          const entryText = section.title;
          const pageNum = section.pageNumber || 1;
          
          // Entry title
          pdf.text(entryText, margins.left + indent, yPosition);
          
          // Dotted line
          const textWidth = pdf.getTextWidth(entryText);
          const pageNumWidth = pdf.getTextWidth(pageNum.toString());
          const dotsSpace = pageWidth - margins.right - margins.left - indent - textWidth - pageNumWidth - 5;
          const dotCount = Math.floor(dotsSpace / 3);
          
          if (dotCount > 0) {
            pdf.setTextColor(150, 150, 150);
            pdf.setFontSize(8);
            const dots = '.'.repeat(dotCount);
            pdf.text(dots, margins.left + indent + textWidth + 2, yPosition);
          }
          
          // Page number
          pdf.setTextColor(40, 40, 40);
          pdf.setFontSize(dotSize);
          pdf.text(pageNum.toString(), pageWidth - margins.right, yPosition, { align: 'right' });
          
          yPosition += section.level === 1 ? 8 : 6;
          
          if (yPosition > pageHeight - margins.bottom - 20) {
            pdf.addPage();
            yPosition = margins.top + 20;
          }
        }
      });
      
      currentPage = pdf.getNumberOfPages() + 1;
    };
    
    // Intelligent page break with content awareness
    const checkPageBreak = (requiredSpace: number, preventOrphans: boolean = true) => {
      const spaceRemaining = pageHeight - margins.bottom - yPosition;
      
      if (spaceRemaining < requiredSpace) {
        // Prevent orphan lines (less than 2 lines remaining)
        if (preventOrphans && spaceRemaining < getLineHeight(fontSize) * 2) {
          pdf.addPage();
          yPosition = margins.top;
          return true;
        } else if (spaceRemaining < requiredSpace) {
          pdf.addPage();
          yPosition = margins.top;
          return true;
        }
      }
      return false;
    };
    
    // Render content with professional formatting
    const renderContent = (sections: DocumentSection[]) => {
      sections.forEach((section, index) => {
        section.pageNumber = pdf.getNumberOfPages();
        
        if (section.level > 0) {
          // Section headers
          checkPageBreak(20);
          
          const headerSizes = { 1: 18, 2: 16, 3: 14, 4: 12, 5: 11, 6: 10 };
          const headerSize = headerSizes[section.level as keyof typeof headerSizes] || 10;
          
          pdf.setFont(getFontConfig('bold'), 'bold');
          pdf.setFontSize(headerSize);
          pdf.setTextColor(30, 30, 30);
          
          // Optimized spacing before headers
          if (index > 0) {
            yPosition += section.level === 1 ? 12 : section.level === 2 ? 8 : 6;
          }
          
          pdf.text(section.title, margins.left, yPosition);
          yPosition += getLineHeight(headerSize) * 0.4;
          
          // Underline for main headers
          if (section.level <= 2) {
            pdf.setDrawColor(section.level === 1 ? 70 : 150, section.level === 1 ? 130 : 150, section.level === 1 ? 180 : 150);
            pdf.setLineWidth(section.level === 1 ? 1.5 : 0.8);
            pdf.line(margins.left, yPosition + 2, margins.left + pdf.getTextWidth(section.title), yPosition + 2);
          }
          
          yPosition += 6;
        }
        
        // Section content
        if (section.content.trim()) {
          renderMarkdownContent(section.content);
        }
      });
    };
    
    // Render markdown content with enhanced formatting
    const renderMarkdownContent = (content: string) => {
      const lines = content.split('\n');
      let inCodeBlock = false;
      let inList = false;
      
      for (const line of lines) {
        const trimmed = line.trim();
        
        if (!trimmed) {
          yPosition += getLineHeight(fontSize) * 0.3; // Reduced empty line spacing
          continue;
        }
        
        checkPageBreak(20);
        
        // Code blocks
        if (trimmed.startsWith('```')) {
          inCodeBlock = !inCodeBlock;
          if (inCodeBlock) {
            yPosition += 5;
            // Code block background
            const codeBlockHeight = 8;
            pdf.setFillColor(248, 248, 248);
            pdf.rect(margins.left - 2, yPosition - 2, pageWidth - margins.left - margins.right + 4, codeBlockHeight, 'F');
          } else {
            yPosition += 5;
          }
          continue;
        }
        
        if (inCodeBlock) {
          pdf.setFont('courier', 'normal');
          pdf.setFontSize(9);
          pdf.setTextColor(60, 60, 60);
          pdf.text(line, margins.left + 5, yPosition);
          yPosition += 5;
          continue;
        }
        
        // Enhanced list formatting with proper spacing
        if (trimmed.match(/^[-\*\+]\s/)) {
          if (!inList) {
            yPosition += 2;
            inList = true;
          }
          
          pdf.setFont(getFontConfig(), 'normal');
          pdf.setFontSize(fontSize);
          pdf.setTextColor(50, 50, 50);
          
          const listText = trimmed.replace(/^[-\*\+]\s/, 'â€¢ ');
          const processedText = processInlineFormatting(listText);
          
          // Use enhanced text wrapping
          const availableWidth = pageWidth - margins.left - margins.right - 10;
          const wrappedLines = wrapText(processedText, availableWidth, fontSize, getFontConfig());
          
          wrappedLines.forEach((textLine: string, index: number) => {
            checkPageBreak(getLineHeight(fontSize));
            pdf.text(textLine, margins.left + (index === 0 ? 8 : 18), yPosition);
            yPosition += getLineHeight(fontSize) * 0.85; // Tighter line spacing for lists
          });
          
          continue;
        } else {
          inList = false;
        }
        
        // Tables (basic support)
        if (trimmed.startsWith('|')) {
          renderTable(line);
          continue;
        }
        
        // Blockquotes
        if (trimmed.startsWith('>')) {
          pdf.setFillColor(245, 245, 245);
          const quoteHeight = 12;
          pdf.rect(margins.left - 2, yPosition - 2, pageWidth - margins.left - margins.right + 4, quoteHeight, 'F');
          
          pdf.setFont(getFontConfig('normal', 'italic'), 'italic');
          pdf.setFontSize(fontSize - 1);
          pdf.setTextColor(80, 80, 80);
          
          const quoteText = trimmed.replace(/^>\s*/, '');
          pdf.text(quoteText, margins.left + 5, yPosition + 2);
          yPosition += 15;
          continue;
        }
        
        // Enhanced paragraph rendering with smart text wrapping
        pdf.setFont(getFontConfig(), 'normal');
        pdf.setFontSize(fontSize);
        pdf.setTextColor(40, 40, 40);
        
        const processedText = processInlineFormatting(trimmed);
        const availableWidth = pageWidth - margins.left - margins.right;
        const wrappedLines = wrapText(processedText, availableWidth, fontSize, getFontConfig());
        
        wrappedLines.forEach((textLine: string, lineIndex: number) => {
          checkPageBreak(getLineHeight(fontSize), true);
          pdf.text(textLine, margins.left, yPosition);
          yPosition += getLineHeight(fontSize) * 0.95; // Optimized line spacing
        });
        
        yPosition += getLineHeight(fontSize) * 0.4; // Reduced paragraph spacing
      }
    };
    
    // Enhanced inline formatting processor with better markdown support
    const processInlineFormatting = (text: string): string => {
      // Clean up excessive whitespace first
      text = text.replace(/\s+/g, ' ').trim();
      
      // Handle code spans by replacing with monospace indicators
      text = text.replace(/`([^`]+)`/g, '[CODE]$1[/CODE]');
      
      // Remove other markdown formatting but preserve structure
      text = text
        .replace(/\*\*(.*?)\*\*/g, '$1')  // Bold - could be enhanced with font switching
        .replace(/\*(.*?)\*/g, '$1')      // Italic - could be enhanced with font switching
        .replace(/\[CODE\](.*?)\[\/CODE\]/g, '$1'); // Restore code content
      
      return text;
    };
    
    // Simple table rendering
    const renderTable = (line: string) => {
      // This is a simplified table implementation
      const cells = line.split('|').map(cell => cell.trim()).filter(cell => cell);
      
      if (cells.length > 0) {
        checkPageBreak(15);
        
        pdf.setFont(getFontConfig(), 'normal');
        pdf.setFontSize(9);
        pdf.setTextColor(40, 40, 40);
        
        const cellWidth = (pageWidth - margins.left - margins.right) / cells.length;
        
        cells.forEach((cell, index) => {
          const x = margins.left + index * cellWidth;
          pdf.rect(x, yPosition - 3, cellWidth, 8);
          pdf.text(cell, x + 2, yPosition);
        });
        
        yPosition += 10;
      }
    };
    
    // Generate the document
    createTitlePage();
    
    const documentSections = parseMarkdownSections(cleanContent);
    
    if (includeTableOfContents && documentSections.some(s => s.level > 0)) {
      createTableOfContents(documentSections);
    }
    
    pdf.addPage();
    yPosition = margins.top;
    renderContent(documentSections);
    
    // Add page numbers and headers
    addPageNumbers();
    
    // Generate filename
    const safeTitle = safeText(title).toLowerCase().replace(/[^a-z0-9]+/g, '-');
    const finalFilename = filename || `${safeTitle}-${formatDate(new Date(), 'yyyy-MM-dd')}.pdf`;
    
    // Save the PDF
    pdf.save(finalFilename);
    console.log('LaTeX-style PDF generated successfully');
    
  } catch (error) {
    console.error('LaTeX-style PDF generation failed:', error);
    throw new Error(`LaTeX-style PDF generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
};

// Sample markdown content for demonstration
export const sampleMarkdown = `# Professional Document Template

Welcome to this beautiful, professionally formatted document that demonstrates the power of our LaTeX-style PDF generation system.

## Introduction

This document showcases various formatting capabilities that make your content look polished and professional. The typography is carefully chosen to be easy on the eyes while maintaining a scholarly appearance.

### Key Features

Our PDF generation system includes:

- **Beautiful Typography**: Clean, readable fonts with proper spacing
- **Professional Layout**: Margins, headers, and page numbers positioned perfectly
- **Table of Contents**: Automatic generation for easy navigation
- **Multiple Formats**: Support for various markdown elements

### Advanced Formatting

You can include various types of content:

#### Code Examples

Here's a simple code block:

\`\`\`javascript
function generatePDF() {
  console.log("Creating beautiful documents!");
  return "Success";
}
\`\`\`

#### Lists and Structure

1. **Ordered Lists**: Perfect for step-by-step instructions
2. **Unordered Lists**: Great for feature highlights
3. **Nested Content**: Supports multiple levels of organization

Key benefits:
- Professional appearance
- Easy to read
- Consistent formatting
- Print-ready quality

#### Quotes and Emphasis

> "The best documents are those that communicate clearly and look professional while doing so."

This system ensures your content always looks its best, whether you're creating:

- Technical documentation
- Business reports  
- Academic papers
- Project proposals

## Technical Specifications

The PDF generation system uses advanced typography principles:

| Feature | Implementation | Quality |
|---------|---------------|---------|
| Font Selection | Professional typefaces | Excellent |
| Spacing | Optimal line height | Superior |
| Layout | LaTeX-inspired margins | Perfect |
| Navigation | TOC generation | Automatic |

## Conclusion

This professional PDF generation system transforms your markdown content into publication-quality documents that are perfect for business, academic, or personal use.

The combination of careful typography, proper spacing, and professional layout ensures your content always makes the best impression.

---

*Generated with care by the Lovable Professional PDF System*`;